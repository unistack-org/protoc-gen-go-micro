package main

import (
	"fmt"
	"strings"

	api_options "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

func (g *Generator) microGenerate(component string, plugin *protogen.Plugin) error {
	for _, file := range plugin.Files {

		if !file.Generate {
			continue
		}

		gname := file.GeneratedFilenamePrefix + "_" + component + ".pb.go"
		gfile := plugin.NewGeneratedFile(gname, ".")

		gfile.P("// Code generated by protoc-gen-micro")
		gfile.P("// source: ", *file.Proto.Name)
		gfile.P("package ", file.GoPackageName)

		gfile.QualifiedGoIdent(protogen.GoIdent{"context", "context"})
		gfile.QualifiedGoIdent(protogen.GoIdent{"api", "github.com/unistack-org/micro/v3/api"})
		gfile.QualifiedGoIdent(protogen.GoIdent{"client", "github.com/unistack-org/micro/v3/client"})
		gfile.QualifiedGoIdent(protogen.GoIdent{"server", "github.com/unistack-org/micro/v3/server"})

		gfile.P("// Reference imports to suppress errors if they are not otherwise used.")
		gfile.P("var (")
		gfile.P("_ ", "api.Endpoint")
		gfile.P("_ ", "context.Context")
		gfile.P(" _ ", "client.Option")
		gfile.P(" _ ", "server.Option")
		gfile.P(")")
		gfile.P()

		// generate services
		for _, service := range file.Services {
			generateService(gfile, service)
		}

	}

	return nil
}

func generateService(gfile *protogen.GeneratedFile, service *protogen.Service) {
	serviceName := strings.TrimSuffix(service.GoName, "Service")
	gfile.P("//New", serviceName, "Endpoints provides api endpoints metdata for ", serviceName, " service")
	gfile.P("func New", serviceName, "Endpoints() []*api.Endpoint {")
	gfile.P("return []*", "api.Endpoint{")
	for _, method := range service.Methods {
		if method.Desc.Options() == nil {
			continue
		}
		if proto.HasExtension(method.Desc.Options(), api_options.E_Http) {
			endpoints, streaming := generateEndpoints(method)
			for _, endpoint := range endpoints {
				gfile.P("&", "api.Endpoint{")
				generateEndpoint(gfile, serviceName, method.GoName, endpoint, streaming)
				gfile.P("},")
			}
		}
	}
	gfile.P("}")
	gfile.P("}")
	gfile.P()
}

func generateEndpoints(method *protogen.Method) ([]*api_options.HttpRule, bool) {
	if method.Desc.Options() == nil {
		return nil, false
	}

	if !proto.HasExtension(method.Desc.Options(), api_options.E_Http) {
		return nil, false
	}

	r := proto.GetExtension(method.Desc.Options(), api_options.E_Http)
	if r == nil {
		return nil, false
	}

	rule := r.(*api_options.HttpRule)
	rules := []*api_options.HttpRule{rule}
	rules = append(rules, rule.GetAdditionalBindings()...)

	return rules, method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient()
}

func generateEndpoint(gfile *protogen.GeneratedFile, serviceName string, methodName string, rule *api_options.HttpRule, streaming bool) {
	var meth string
	var path string
	switch {
	case len(rule.GetDelete()) > 0:
		meth = "DELETE"
		path = rule.GetDelete()
	case len(rule.GetGet()) > 0:
		meth = "GET"
		path = rule.GetGet()
	case len(rule.GetPatch()) > 0:
		meth = "PATCH"
		path = rule.GetPatch()
	case len(rule.GetPost()) > 0:
		meth = "POST"
		path = rule.GetPost()
	case len(rule.GetPut()) > 0:
		meth = "PUT"
		path = rule.GetPut()
	case rule.GetCustom() != nil:
		crule := rule.GetCustom()
		meth = crule.Kind
		path = crule.Path
	}
	if len(meth) == 0 || len(path) == 0 {
		return
	}

	gfile.P("Name:", fmt.Sprintf(`"%s.%s",`, serviceName, methodName))
	gfile.P("Path:", fmt.Sprintf(`[]string{"%s"},`, path))
	gfile.P("Method:", fmt.Sprintf(`[]string{"%s"},`, meth))
	if len(rule.GetGet()) == 0 {
		gfile.P("Body:", fmt.Sprintf(`"%s",`, rule.GetBody()))
	}
	if streaming {
		gfile.P("Stream: true,")
	}
	gfile.P(`Handler: "rpc",`)

	return
}
